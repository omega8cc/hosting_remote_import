<?php

 /**
  * @file
  *   A 'hostmaster' implementation of the 'remote_import' service type.
  */

/**
 * A class containing the 'hostmaster' implementation of the 'remote_import' service.
 *
 * This class is conditionally loaded when the "--remote_import_service_type=hostmaster"
 * option is passed to provision-save commands run on servers.
 *
 * The above flag is generated by the hosting counterpart of this class, which
 * provides the front end to configure all these fields.
 *
 * The responsibilities of this class include responding and saving any
 * values that are passed to it, and also to override the portions of
 * the public API for this service that are necessary.
 */
class Provision_Service_remote_import_hostmaster extends Provision_Service_remote_import {
 /**
  * Some common options handled upstream by the base service classes.
  */

  /**
   * {@inheritdoc}
   */
  public function init_server() {
    parent::init_server();
    $this->server->setProperty('remote_user', '');
  }

  /**
   * Initialize this class, including option handling.
   */
  function init() {
    // REMEMBER TO CALL THE PARENT!
    parent::init();
    /**
     * Setting and storing a value.
     *
     * You will most commonly use :
     *    $this->server->setProperty('remote_import_field', 'default');
     *
     * This helper will check for an existing saved value, overridden
     * by a command line option falling back to the default.
     *
     * This is the format used by everything you want configurable from
     * the front end or command line.
     *
     * These values will be saved in ~/.drush/server_name.drush.alias.inc.
     */
    $this->server->setProperty('remote_import_field', 'default');
  }

  function list_sites() {
    $sites = array();

    $result = $this->remote_execute('@hostmaster variable-get aegir_api --format=string', array(), FALSE);
    $aegir_api = trim($result['output']);
    $api_parts = explode(':', $aegir_api);
    if (sizeof($api_parts) >= 2) {
      $aegir_api = trim($api_parts[1]);
    }

    drush_log(dt('Remote Aegir API version: ') . $aegir_api);

    if ($aegir_api == 3) {
       // We talk to the remote Aegir, and get it to list the sites it has.
       // We need to bootstrap the remote hostmaster.
       $lines[] = 'drush_bootstrap(DRUSH_BOOTSTRAP_DRUPAL_FULL)';
       $lines[] = '$sites = array()';
       $lines[] = '$results = db_query("SELECT sn.title as site, pn.title as platform
                                         FROM {hosting_site} hs
                                   INNER JOIN {node} sn
                                           ON hs.nid = sn.nid
                                   INNER JOIN {hosting_platform} hp
                                           ON hs.platform = hp.nid
                                   INNER JOIN {node} pn
                                           ON hp.nid = pn.nid
                                        WHERE hs.status IN(:disabled, :enabled)", array(
                                                ":disabled" => HOSTING_SITE_DISABLED,
                                                ":enabled" => HOSTING_SITE_ENABLED,
                                              ))';
       $lines[] = 'foreach ($results as $result) {';
       $lines[] = '  $sites[$result->site] = $result->platform';
       $lines[] = '}';
       // Set the $sites array into the backend result, so we can extract it easily
       // later.
       $lines[] = 'drush_backend_set_result($sites)';
    }
    elseif ($aegir_api == 2) {
       // We talk to the remote Aegir, and get it to list the sites it has.
       // We need to bootstrap the remote hostmaster.
       $lines[] = 'drush_bootstrap(DRUSH_BOOTSTRAP_DRUPAL_FULL)';
       $lines[] = '$sites = array()';
       $lines[] = '$results = db_query("SELECT sn.title as site, pn.title as platform
                                         FROM {hosting_site} hs
                                   INNER JOIN {node} sn
                                           ON hs.nid = sn.nid
                                   INNER JOIN {hosting_platform} hp
                                           ON hs.platform = hp.nid
                                   INNER JOIN {node} pn
                                           ON hp.nid = pn.nid
                                        WHERE hs.status IN(-1, 1)")';
       $lines[] = 'while ($r = db_fetch_object($results)) {';
       $lines[] = '  $sites[$r->site] = $r->platform';
       $lines[] = '}';
       // Set the $sites array into the backend result, so we can extract it easily
       // later.
       $lines[] = 'drush_backend_set_result($sites)';
    }
    else {
      drush_set_error('AEGIR_REMOTE_IMPORT_UNSUPPORTED_API', dt('Remote import only supports importing from Aegir 2 or Aegir 3 remotes. The API version received was: ') . $aegir_api);
    }


    // Execute the PHP we wrote in $lines on the remote server.
    $result = $this->remote_execute('@hostmaster php-eval', array(implode(';', $lines) . ';'));

    // If the PHP suceeeds, the result will be in the 'object' key.
    if (isset($result['object']) && is_array($result['object'])) {
      return $result['object'];
    }

    return FALSE;
  }

  function remote_execute($command, $data = array(), $integrate = TRUE) {
    $data += array(
      'root' => NULL,
      'uri' => NULL,
    );

    $config = array('remote-host' => $this->server->remote_host);
    if (!empty($this->server->remote_user)) {
      $config['remote-user'] = $this->server->remote_user;
    }
    else {
      $config['remote-user'] = $this->server->script_user;
    }

    return drush_invoke_process($config, $command, $data, array(), array(
      'method' => 'POST',
      'integrate' => $integrate,
    ));
  }

  function fetch_site($site) {
    // Do a backup on the remote server.
    $remote_backup_file = $this->remote_backup($site);

    // And now fetch that backup.
    $local_file = d('@hostmaster')->platform->server->backup_path . '/' . basename($remote_backup_file);
    $this->fetch_path($remote_backup_file, $local_file);

    // And now delete the backup just fetched.
    $this->remote_execute('provision-backup-delete', array($remote_backup_file));

    return $local_file;
  }

  function fetch_path($path, $dest) {
    $options = array(
      'omit-dir-times' => TRUE,
    );

    $user = $this->server->script_user;
    if (!empty($this->server->remote_user)) {
      $user = $this->server->remote_user;
    }

    $user_and_host = escapeshellarg($user . '@' . $this->server->remote_host . ':/');
    if (drush_core_call_rsync($user_and_host . $path, $dest, $options, TRUE, FALSE)) {
      drush_log(dt('@path has been fetched from remote server @remote_host.', array(
        '@path' => $path,
        '@remote_host' => $this->server->remote_host))
      );
    }
    else {
      drush_set_error('PROVISION_FILE_SYNC_FAILED', dt('@path could not be fetched from remote server @remote_host.' .
        ' Changes might not be available until this has been done. (error: %msg)', array(
          '@path' => $path,
          '@remote_host' => $this->server->remote_host,
          '%msg' => join("\n", drush_shell_exec_output())))
      );
    }
  }

  function remote_backup($site) {
    $result = $this->remote_execute('@' . $site . ' provision-backup');

    if (isset($result['context']['backup_file'])) {
      return $result['context']['backup_file'];
    }

    return FALSE;
  }

  function fetch_settings($old_url) {
    $settings = array();

    $lines = array();
    $lines[] = 'drush_backend_set_result(d()->options)';

    // Execute the PHP we wrote in $lines on the remote server.
    $result = $this->remote_execute('@' . $old_url . ' php-eval', array(implode(';', $lines) . ';'));

    // If the PHP suceeeds, the result will be in the 'object' key.
    if (isset($result['object']) && is_array($result['object'])) {
      $remote_settings = $result['object'];
      // Now copy the settings we need:
      foreach ($this->remote_settings_to_copy() as $setting) {
        if (isset($remote_settings[$setting])) {
          $settings[$setting] = $remote_settings[$setting];
        }
      }
    }

    return $settings;
  }

  function remote_settings_to_copy() {
    $settings = array(
      'profile',
      'language',
    );
    // Allow other commands to alter the settings to copy.
    $modules = drush_command_implements('remote_import_hostmaster_remote_setings_to_copy_alter');
    foreach ($modules as $name) {
      $func = "{$name}_remote_import_hostmaster_remote_setings_to_copy_alter";
      $func($settings);
    }
    return $settings;
  }

  /**
   * Implementation of service verify.
   */
  function verify_server_cmd() {
    parent::verify_server_cmd();
    // We should try to connect to the remote hostmaster server.
    $result = $this->remote_execute('@hostmaster status');
    if (
      (!isset($result['object']['Drupal bootstrap']) || ($result['object']['Drupal bootstrap'] != 'Successful')) &&
      (!isset($result['object']['bootstrap']) || ($result['object']['bootstrap'] != 'Successful'))
    ) {
      return drush_set_error('REMOTE_SERVER_IS_NOT_MASTER', dt('The specified server is not an Aegir master server.'));
    }
  }
}
